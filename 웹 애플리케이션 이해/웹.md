### 웹 서버, 웹 애플리케이션 서버

<br/>

웹은 HTTP를 기반으로 전송이 이루어진다. 단순 HTML부터 시작해 이미지, 영상, JSON(API) 등 거의 모든 형태의 데이터를 주고 받을 때 HTTP를 사용한다.

#### 웹 서버(Web Server)


<br/>

웹 서버는 HTTP 기반으로 동작한다. 중요한 특징으로 정적 리소스를 제공한다는 것이다.  <br/>
정적 리소스는 HTML, CSS, JS, 이미지, 영상과 같은 파일들을 말한다.

ex) NGINX, APACHE

기능 1) <br/>
* 정적인 컨텐츠 제공 <br/>
* WAS를 거치지 않고 바로 자원을 제공한다.

기능 2) <br/>
* 동적인 컨텐츠 제공을 위한 요청 전달 <br/> 
* 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다. <br/>
* 클라이언트는 일반적으로 웹 브라우저를 의미한다.

<br/>

#### 웹 애플리케이션 서버(WAS - Web Application Server)

<br/>

DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server <br/>
웹 애플리케이션 서버 역시 HTTP 기반으로 동작하며, 웹 서버의 기능을 포함한다.(정적 리소스 제공 가능)  <br/>
WAS는 프로그램 코드를 실행하여 애플리케이션 로직을 수행할 수 있다는 특징이 있다.  <br/>
동적 HTML, HTTP API(JSON), 서블릿, JSP, 스프링MVC 등을 코드에 따라 제공할 수 있다. 

즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

<br/>

ex) 톰캣(Tomcat), Jetty, Undertow

<br/>

- 웹 서버와의 차이

웹 서버는 정적 리소스, WAS는 애플리케이션 로직 <br/>
+) 사실 웹 서버도 프로그램을 실행하는 기능을 포함하기도 하고, WAS도 웹 서버의 기능을 제공하기 때문에 둘의 경계가 모호하긴 하다.

자바는 서블릿 컨테이너 기능을 제공하면 WAS라고 한다. (서블릿은 밑에서 다루겠다) <br/>
+) 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있다.

-> 결국 중요한 것은 WAS는 애플리케이션 코드를 실행하는데 더 특화되어 있다는 것이다.

<br/>

- 웹 시스템 구성 - WAS, DB

![image](https://user-images.githubusercontent.com/78454649/165036504-34193f36-948b-4e4f-a2ff-76bceb2427ae.png)


WAS가 정적 리소스, 애플리케이션 로직 모두 제공 가능하기 때문에 WAS, DB만으로 시스템 구성이 가능하다.

<br/>

- 웹 시스템 구성 - WEB, WAS, DB

WAS, DB는 유지하되 정적 리소스는 웹 서버가 따로 처리하는 방식이다.  <br/>
웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임한다. WAS는 정적 리소스가 아닌 애플리케이션 로직 처리를 전담한다.

![image](https://user-images.githubusercontent.com/78454649/165036941-be98cca9-2bce-4384-99f1-79692704d013.png)


이 방식은 효율적인 리소스 관리를 기대할 수 있다.
* 정적 리소스가 많이 사용되면 웹 서버를 증설하고 애플리케이션 리소스가 많이 사용되면 WAS를 증설한다.
* 정적 리소스만 제공하는 웹 서버는 보통 잘 죽지 않고, 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽는다. 

따라서 WAS, DB 장애시 웹 서버가 오류 화면을 제공할 수 있다.

<br/>

#### 그렇다면 WAS가 Web Server의 기능도 모두 수행하면 되지 않을까?

기능을 분리하여 서버 부하 방지
* WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 정적 컨텐츠는 Web Server에서 빠르게 클라이언트에 제공하는 것이 좋다.
* WAS는 기본적으로 동적 컨텐츠를 제공하기 위해 존재하는 서버이다.
* 만약 정적 컨텐츠 요청까지 WAS가 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다.
* 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다.

<br/>

물리적으로 분리하여 보안 강화
* SSL에 대한 암복호화 처리에 Web Server를 사용

<br/>

여러 대의 WAS를 연결 가능
* Load Balancing을 위해서 Web Server를 사용
* fail over(장애 극복), fail back 처리에 유리
* 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
* 예를 들어, 앞 단의 Web Server에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다.

---

<br/>

### 서블릿

<br/>

아래와 같이 웹 브라우저가 생성한 요청 HTTP 메시지가 있다고 하자. (회원 저장)

```java
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded
username=kim&age=20
```

이 때, WAS에서 처리해야 하는 업무는 다음과 같다.

* 서버 TCP/IP 연결 대기, 소켓 연결
* HTTP 요청 메시지를 파싱해서 읽기
* POST 방식, /save URL 인지 확인
* Content-Type 확인
* HTTP 메시지 바디 내용 파싱 -> username, age 데이터를 사용할 수 있게 파싱
* 저장 프로세스 실행
* 비즈니스 로직 실행 -> 데이터 베이스에 저장 요청
* HTTP 응답 메시지 생성 시작 -> HTTP 시작 라인 생성, Header 생성, 메시지 바디에 HTML 생성해서 입력
* TCP/IP에 응답 전달, 소켓 종료

대충 훑어봐도 정말 복잡해보인다. 이를 개발자가 전부 직접 구현한다면 비효율적인 작업이 될 것이다. <br/>
왜냐하면 의미있는 비즈니스 로직을 실행하는 것을 제외한 나머지 작업들은 거의 반복적인 작업에 해당되기 때문이다.

그렇다면 서블릿을 지원하는 WAS를 사용할 때 서버에서 직접 처리해야 하는 업무는 어떨까

비즈니스 로직 실행 -> 데이터 베이스에 저장 요청 , 을 제외한 모든 요청은 서블릿에서 지원한다

<br/>

이처럼 개발자는 의미 있는 비즈니스 로직만을 작성하면 나머지는 알아서 서블릿에서 지원한다. -> 보다 효율적인 작업이 가능해진다.

```java

@WebServlet(name = "helloServlet", urlPatterns = "/hello")
public class HelloServlet extends HttpServlet {
   @Override
   protected void service(HttpServletRequest request, HttpServletResponse response){
   		//애플리케이션 로직
   }
}

```

일반적인 서블릿 코드다. urlPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행된다.

HttpServelt을 상속받는 HelloServelt클래스에서 service() 메서드가 자동 실행된다.
* HttpServletRequest : HTTP 요청 정보를 편리하게 사용할 수 있는 변수
* HttpServletResponse : HTTP 응답 정보를 편리하게 제공할 수 있는 변수

따라서 개발자는 HTTP 스펙을 매우 편리하게 사용한다.  <br/>
-> request의 정보(username, age)들을 사용해 데이터베이스에 저장하고 response에 정보를 넣어준다.

<br/>

* 서블릿 컨테이너

웹 브라우저 요청에 따라 서블릿을 지원하는 WAS에서 데이터가 처리되는 과정을 보자.

![image](https://user-images.githubusercontent.com/78454649/165043800-c7d1108b-c5be-4339-a635-e819ca374dcb.png)

1. HTTP 요청 
2. WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
3. 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
4. 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
5. WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

<br/>

 이 때, 서블릿 객체를 갖고 있는 서블릿 컨테이너는 무엇일까?

톰캣처럼 서블릿을 지원하는 WAS를 서블릿 컨테이너라고 한다. 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기를 관리한다. <br/>
서블릿 객체는 싱글톤으로 관리된다. -> 공유 변수 사용 주의, 서블릿 컨테이너 종료시 함께 종료 <br/>
JSP도 서블릿으로 변환 되어서 사용된다. (JSP는 이후에 다루겠다) <br/>
동시 요청을 위한 멀티 쓰레드 처리를 지원한다. -> 개발자는 멀티 쓰레드에 대한 신경을 줄일 수 있다. <br/>

<br/>

---

<br/>

### 멀티 쓰레드

백엔드 개발자는 멀티쓰레드 개념을 숙지하는 것이 정말 중요하다. WAS 안에서도 쓰레드가 서블릿 객체 호출을 담당한다. 쓰레드는 무엇일까?

![image](https://user-images.githubusercontent.com/78454649/165044291-b3d2c901-6866-420d-8683-963c992995c3.png)

과연 서블릿을 누가 호출할까? 

<br/>

#### 쓰레드


애플리케이션 코드를 하나하나 순차적으로 실행하는 것이 쓰레드이다. <br/>
자바의 경우 main 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행된다. 만약 동시 처리가 필요한 경우 쓰레드를 추가로 생성해야 한다.

 
단일 쓰레드 : 다중 요청 상황이라면 요청1이 처리중일 때 요청2는 대기하게 된다. <br/>
만약 요청1 처리가 지연된다면 결국 두 요청 모두 응답할 수 없게 된다.

그러나 요청마다 쓰레드를 생성하는 경우를 생각해보면 요청1이 지연되어도 요청2에서 <br/>
신규 쓰레드가 생성되기 때문에 순조롭게 요청2에 대한 응답을 할 수 있게 된다.


요청마다 쓰레드를 생성하는 경우의 장단점은 다음과 같다.

장점<br/>
* 동시 요청을 처리할 수 있다.
* 리소스(CPU, 메모리)가 허용할 때까지 처리 가능하다.
* 하나의 쓰레드가 지연되어도, 나머지 쓰레드는 정상 동작한다.

단점<br/>

* 쓰레드는 생성 비용이 매우 비싸다. -> 요청이 올 때마다 쓰레드를 생성하면 응답 속도가 늦어진다.
* 쓰레드는 컨텍스트 스위칭 비용이 발생한다.
* 쓰레드 생성에 제한이 없다. -> 요청이 너무 많이 오면, CPU, 메모리 임계점을 넘어서 서버가 죽을 수 있다.

<br/>

#### 쓰레드 풀

<br/>

쓰레드 풀은 미리 여러 쓰레드들을 갖고 있다가 매 요청마다 쓰레드를 생성하는 것이 아닌 쓰레드 풀 내에 쓰레드를 제공하는 방식이다.<br/>
만약 쓰레드 풀 내에 휴식 중인 쓰레드가 없다면 요청을 대기 혹은 거절한다.


<요청 마다 쓰레드 생성의 단점 보완>

![image](https://user-images.githubusercontent.com/78454649/165051703-ff741cfb-4fe5-4dd1-887a-484f9e6c4845.png)


사용 <br/>

* 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.
* 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
* 최대 쓰레드가 모두 사용중이라면 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.

장점 <br/>

* 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용이 절약되고, 응답 시간이 빠르다.
* 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

<br/>

<쓰레드 풀 - 실무 팁>

WAS의 주요 튜닝 포인트는 최대 쓰레드 수이다. -> 최대 쓰레드를 수정했을 때 좋은 효과를 볼 확률이 크다.

 

- 이 값을 너무 낮게 설정하면?

동시 요청이 많으면, 서버 리소스는 여유롭지만 클라이언트는 금방 응답이 지연된다.

ex) 200개 스레드까지 지원하는 CPU에서 최대 쓰레드를 10개로 설정했다면 CPU의 5%만을 사용하는 것이다.  <br/>
최대 쓰레드 이상의 요청에 대한 클라이언트 지연이 최대 쓰레드 문제인지도 모르고 <br/>
서버를 여러 대로 추가 증설해서 해결한다면  더 많은 비용이 든다.

 

- 이 값을 너무 높게 설정하면?

동시 요청이 많으면, CPU, 메모리 리소스 임계점 초과로 서버가 다운된다. <br/>
-> 장애 발생 시 일단 서버부터 늘리고 급한 불을 끈 뒤 이후에 튜닝한다.

 

- 쓰레드 풀의 적정 숫자?

애플리케이션 로직의 복잡도, CPU, 메모리 등의 상황에 따라 모두 다르다. <br/>
-> 그래서 최대한 실제 서비스와 유사하게 성능 테스트를 하는 것이 중요하다.

---

<br/>

### HTML, HTTP API, CSR, SSR

<br/>

#### 정적 리소스

고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공<br/>
예를 들어 웹 브라우저가 단순히 hello.html을 요청하면 웹 서버에서 해당 정적 리소스 파일을 그대로 보내준다.

<br/>

#### HTML 페이지


이제부터 웹 애플리케이션의 영역이다. 동적으로 필요한 HTML 파일을 생성해서 전달한다.

ex) <br/>
1. 웹 브라우저 요청 /orders.html
2. WAS에서 DB에 주문 정보 조회
3. DB 정보를 기반으로 동적으로 HTML 생성 (JSP, 타임리프)
4. 웹 브라우저에 전송, 웹 브라우저는 HTML을 해석하여 화면에 출력

<br/>

#### HTTP API

HTML이 아니라 데이터를 전달한다. 주로 JSON 형식을 사용한다.

![image](https://user-images.githubusercontent.com/78454649/165226999-cf01b514-3f77-4533-bdfd-7ae68f9f676a.png)


ex) <br/>
1. 웹 브라우저 요청 /orders
2. WAS에서 DB에 주문 정보 조회
3. DB 정보를 JSON 형식으로 웹 브라우저에 전송

<br/>

#### SSR, CSR

![image](https://user-images.githubusercontent.com/78454649/165227260-075cb43b-2c7a-4df4-8be9-4fcc3498d1ea.png)


SSR, 서버 사이드 렌더링
* HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
* 주로 정적인 화면에 사용
* 관련 기술 : JSP, 타임리프 -> 백엔드 개발자 (지금까지 스프링 공부시 구현한 방식이 SSR이다.)


![image](https://user-images.githubusercontent.com/78454649/165227280-3e45f46f-fd29-464e-a262-db3ab1d77140.png)


CSR, 클라이언트 사이드 렌더링
* HTML 결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용
* 주로 동적인 화면에 사용, 웹 환경을 부분부분 변경할 수 있다.
* ex) 구글 지도 -> 지도를 움직이거나 확대해도 URL이 변경되거나 하지 않는다.
* 관련 기술 : React, Vue.js -> 웹 프론트엔드 개발자


<CSR은 어떤 과정으로 HTML 결과를 렌더링할까?>

1. 클라이언트 -> HTML 요청 / 서버 -> 자바스크립트 링크
2. 클라이언트 -> 자바스크립트 요청 / 서버 -> 자바스크립트 로직, HTML 렌더링 코드
3. 클라이언트 -> HTTP API를 통해 데이터 요청 / 서버 -> JSON 데이터
4. 클라이언트 -> JSON 데이터를 자바스크립트 로직과 HTML 렌더링 코드로 화면 출력



















