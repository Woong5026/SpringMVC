### 요구사항 분석

<상품 도메인>

모델 상품 ID <br/>
상품명 <br/>
가격 <br/>
수량

<상품 관리 기능>

상품 목록 <br/>
상품 상세 <br/>
상품 등록 <br/>
상품 수정

<서비스 흐름>

![image](https://user-images.githubusercontent.com/78454649/174251702-7f7c9c88-1b23-4554-9215-ee79b4e851be.png)

<br/>

### 상품 도메인 개발

* Item

```java

@Data
public class Item {

    private Long id;
    private String itemName;
    private Integer price;
    private Integer quantity;

    public Item() {
    }

    public Item(String itemName, Integer price, Integer quantity) {
        this.itemName = itemName;
        this.price = price;
        this.quantity = quantity;
    }
}

```

+) 참고 <br/>
롬복 사용시 @Data는 이런 핵심 도메인에서는 위험할 수 있다. (ex. @ToString - 양방향 연관관계 무한 루프) <br/>
@Getter, @Setter 혹은 @Getter 정도만 열어두는 것이 좋다. (Dto에서는 @Data를 조심히 사용해도 좋다)

<br/>

* itemRepository

```java

@Repository
public class ItemRepository {

    private static final Map<Long, Item> store = new HashMap<>(); //static , 싱글톤은 보장하기 위해
    private static long sequence = 0L; //static

    public Item save(Item item) {
        item.setId(++sequence);
        store.put(item.getId(), item);
        return item;
    }

    public Item findById(Long id) {
        return store.get(id);
    }

    public List<Item> findAll() {
        return new ArrayList<>(store.values());
    }

    public void update(Long itemId, Item updateParam) {
        Item findItem = findById(itemId);
        findItem.setItemName(updateParam.getItemName());
        findItem.setPrice(updateParam.getPrice());
        findItem.setQuantity(updateParam.getQuantity());
    }

    public void clearStore() {
        store.clear();
    }
}

```

저장소는 정적 메모리 저장소를 사용하고, id 값을 위해 정적 변수 sequence를 사용한다.<br/>
+) 싱글톤을 사용하기 때문에 사용자 동시 접근을 고려하여 ConcurrentHashMap이나 AtomicLong을 사용하는 것이 좋다. (여기서는 간단히)

+) 상품 목록의 경우 ArrayList로 한 번 감쌌는데 이는 중간에 store가 <br/>
수정되는 등의 상황에 대해 안전하게 상품 목록을 반환해주기 위해서이다.

+) 상품 수정에서 setter를 세 번 사용했는데 사실 정석은 세 필드를 포함하는 Dto를 통해 수정 정보를 명확히 하는 것이 좋다.

<br/>

---

<br/>

### 상품 서비스 HTML

































